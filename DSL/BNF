

# Non-terminal definitions

Start ::= ProgramBlock         # Entry point



NumericExpr ::= AddSub


AddSub ::= MulDiv AddSub'
 
AddSub' ::= + MulDiv AddSub'
            | - MulDiv AddSub'
            | <epsilon>


MulDiv ::= NumericType MulDiv'

MulDiv' ::= * NumericType MulDiv' 
            | / NumericType MulDiv' 
            | <epsilon>


NumericType ::= - <number>
                | <number>
                | (AddSub)
                | ConstNumericType       # Type has to be checked!


ConstNumericType ::= <identifier> ConstNumericProperty       # Either a const with numeric value or a point with property access specifier

ConstNumericProperty ::= . ConstNumericProperty' | <epsilon>

ConstNumericProperty' ::= longitude | latitude



PointType ::= < NumericExpr , NumericExpr >    # Declared this way to prevent collisions with numeric expressions wrapped in () and to add extra clarity


PolygonType ::= Polygon ( PolygonPoints )

PolygonPoints ::= PointType PolygonPoints'

PolygonPoints' ::= , PolygonPoints
                   | <epsilon>


CircleType ::= Circle ( PointType , <number> )

BoxType ::= Box ( PointType , PointType )

PolyLineType ::= PolyLine ( <number> , PolygonPoints )


BoundsType ::= PolygonType
               | CircleType
               | BoxType
               | PolyLineType


ConstDef ::= const <identifier> = ConstValue ;

ConstValue ::= NumericExpr
               | PointType
               | PolygonType
               | import <string>
               | LambdaExpr


PropertyDef ::= . <identifier> : PropertyValue ;

PropertyValue ::= <number>
                  | <string>
                  | BoundsType
                  | ConstBoundsType
                  | null


ConstBoundsType ::= <identifier> ConstArrayIndexed       # Constant type needs to be checked to be either BoundsType or imported array

ConstArrayIndexed ::= [ <integer> ] | <epsilon>


LambdaExpr ::= lambda ( LambdaParams ) { LambdaBody }

LambdaParams ::= <identifier> LambdaParams'

LambdaParams' ::= , <identifier> LambdaParams'
                  | <epsilon>

LambdaBody ::= ConstDefList ReturnValue ;        # We either have some constant definitions followed by a return statement or only a return statement

ConstDefList ::= ConstDef ConstDefList | <epsilon>      # List of 0 or more ConstDef-s

ReturnValue ::= return ReturnType ;

ReturnType ::= <number> | BoundsType



# Flow control

ForEachLoop ::= foreach <identifier> in <identifier> { BlockContent }


IfStatement ::= if ( BooleanExpr ) { BlockContent } ElseBlock

ElseBlock ::= else { BlockContent }       # else block is optional
              | <epsilon>


ControlFlowDef ::= ForEachLoop
                   | IfStatement


BooleanExpr ::= NumericExpr BooleanOperator NumericExpr

BooleanOperator ::= > | <



                  
# Main feature blocks

CadastreBlock ::= cadastre { CadastreContent }

CadastreContent ::= CadastreContent' CadastreContent | <epsilon>       # This allows for empty cadastre blocks which will have to be checked for

CadastreContent' ::= BlockContent'
                     | LotBlock



BlockContent ::= BlockContent' BlockContent | <epsilon>         # This allows for empty blocks!

BlockContent' ::= ConstDef
                | PropertyDef
                | ControlFlowDef


# Lot block and syntactic sugar for it
LotBlock ::= lot { BlockContent }
             | RoadLot
             | BuildingLot
             | FarmLandLot
             | ForestLot
             | MeadowLot
             | RiverLot
             | LakeLot

LotSimplifiedArgs ::= ( <string> , BoundsType ) ;

RoadLot ::= road LotSimplifiedArgs
BuildingLot ::= buildingLot LotSimplifiedArgs
FarmLandLot ::= farmLand LotSimplifiedArgs
ForestLot ::= forest LotSimplifiedArgs
MeadowLot ::= meadow LotSimplifiedArgs
RiverLot ::= river LotSimplifiedArgs
LakeLot ::= lake LotSimplifiedArgs


# Risk block with syntactic sugar
RiskBlock ::= risk { BlockContent }
              | FloodRisk
              | LandSlideRisk
              | EarthQuakeRisk

RiskSimplifiedArgs ::= ( BoundsType , NumericExpr , NumericExpr ) ;          # bounds, probability, frequency

FloodRisk ::= flood RiskSimplifiedArgs
LandSlideRisk ::= landSlide RiskSimplifiedArgs
EarthQuakeRisk ::= earthQuake RiskSimplifiedArgs


ProgramBlock ::= ProgramBlock' ProgramBlock | <epsilon>

ProgramBlock' ::= ConstDef
                  | CadastreBlock
                  | RiskBlock





# Terminal definitions

<epsilon> = <void of space>

<number> = \d+(?:\.\d+)?

<integer> = \d+

<string> = "([^"]*)"   #match group = string data

<identifier> = [a-zA-Z_$][a-zA-Z_$0-9]*